# -*- coding: utf-8 -*-
"""MoovAI_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eA9E7aF87tGFFB8hCaceU8vYGgjNFMEk

MoovAI Sales Forecasting - Machine Learning Model

This script processes historical sales data, extracts insights, and builds machine learning models
to predict future sales. It includes data cleaning, feature engineering, model training,
and evaluation.
"""

# import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# upload dataset
file_path = "/content/stores_sales_forecasting.csv"
df = pd.read_csv(file_path, encoding="Windows-1252")

# display the first few rows of the dataset
df.head()

# display the dataset info
df.info()

# check missing values
print("\nMissing values:")
print(df.isnull().sum())

# check duplicate values
print("\nDuplicate values:")
print(df.duplicated().sum())

# display basic statistics using numeric values
print("\nBasic statistics:")
print(df.describe())

categorical_cols = ["Region", "Category", "Ship Mode", "Segment", "Country", "City", "State", "Sub-Category"]

# convert to datetime format
df["Order Date"] = pd.to_datetime(df["Order Date"], format="%m/%d/%Y")

# extract month
df["Month"] = df["Order Date"].dt.month

# check strings and remove spaces
df[categorical_cols] = df[categorical_cols].apply(lambda x: x.astype(str).str.strip())

# one-hot encoding
df_encoded = pd.get_dummies(df, columns=categorical_cols, drop_first=True)

# check
df_encoded.head()

# profit by month
monthly_sales = df.groupby("Month")["Sales"].sum()
monthly_profit = df.groupby("Month")["Profit"].sum()

# dual-axis plot
fig, ax1 = plt.subplots(figsize=(8, 4))

# plot sales
ax1.set_title("Sales and Profit by Month", fontsize=12)
ax1.set_xlabel("Month")
ax1.set_ylabel("Sales", color="blue")
sns.lineplot(x=monthly_sales.index, y=monthly_sales.values, marker="o", ax=ax1, color="blue", label="Sales")

# axis for profit
ax2 = ax1.twinx()
ax2.set_ylabel("Profit", color="red")
sns.lineplot(x=monthly_profit.index, y=monthly_profit.values, marker="o", ax=ax2, color="red", label="Profit")

plt.show()

# sales by region
region_sales = df.groupby("Region")["Sales"].sum().sort_values(ascending=False)

# plot
plt.figure(figsize=(8, 4))
sns.barplot(x=region_sales.index, y=region_sales.values)
plt.title("Sales by Region", fontsize=12)
plt.xlabel("Region")
plt.ylabel("Sales")
plt.xticks(rotation=45)

plt.show()

# sales by sub-category
category_sales = df.groupby("Sub-Category")["Sales"].sum().sort_values(ascending=False)

# plot
plt.figure(figsize=(8, 4))
sns.barplot(x=category_sales.index, y=category_sales.values)
plt.title("Sales by Product Category", fontsize=12)
plt.xlabel("Product Category")
plt.ylabel("Sales")
plt.xticks(rotation=45)

plt.show()

# create boxplots to check outliers
fig, axes = plt.subplots(1, 4, figsize=(18, 5))

sns.boxplot(y=df["Sales"], ax=axes[0])
axes[0].set_title("Sales")

sns.boxplot(y=df["Discount"], ax=axes[1])
axes[1].set_title("Discount")

sns.boxenplot(y=df["Profit"], ax=axes[2])
axes[2].set_title("Profit")

sns.boxenplot(y=df["Quantity"], ax=axes[3])
axes[3].set_title("Quantity")

plt.tight_layout()
plt.show()

# create plot to check the impact
plt.figure(figsize=(8, 5))
sns.scatterplot(x=df["Quantity"], y=df["Profit"], alpha=0.5)
plt.title("Quantity vs Profit")
plt.xlabel("Quantity")
plt.ylabel("Profit")
plt.show()

# create plot to check the impact
plt.figure(figsize=(8, 5))
sns.scatterplot(x=df["Discount"], y=df["Profit"], alpha=0.5)
plt.title("Discount vs Profit")
plt.xlabel("Discount")
plt.ylabel("Profit")
plt.show()

# create new features
df["Profit Margin"] = df["Profit"] / df["Sales"]
df["Discount Impact"] = df["Discount"] * df["Sales"]
df["Profit Rate"] = df["Profit"] / (df["Sales"] - df["Discount Impact"])

# add to df_encoded
for col in ["Profit Margin", "Discount Impact", "Profit Rate"]:
    if col in df.columns:
        df_encoded[col] = df[col]

# create
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# profit margin
sns.histplot(df["Profit Margin"], bins=25, kde=True, ax=axes[0])
axes[0].set_title("Profit Margin")

# discount impact
sns.histplot(df["Discount Impact"], bins=25, kde=True, ax=axes[1])
axes[1].set_title("Discount Impact")

# profit rate
sns.histplot(df["Profit Rate"], bins=25, kde=True, ax=axes[2])
axes[2].set_title("Profit Rate")

plt.tight_layout()
plt.show()

# create dataframe for correlation
df_feat = ["Profit", "Sales", "Quantity", "Discount Impact", "Month", "Profit Margin", "Profit Rate"]

df_feat_selected = df_encoded.copy()
for col in df_feat:
    if col in df.columns:
        df_feat_selected[col] = df[col]

# just numeric cols
df_feat_numeric = df_feat_selected.select_dtypes(include=["number"])[df_feat]

# compute correlations
feature_correlation = df_feat_numeric.corr()

# plot heatmap
plt.figure(figsize=(9, 7))
sns.heatmap(feature_correlation, annot=True, cmap="coolwarm", fmt=".2f", linewidths=1, annot_kws={"size": 12}, vmin=-1, vmax=1, square=True, cbar_kws={"shrink": 0.8})
plt.xticks(rotation=45, ha="right", fontsize=12)
plt.yticks(fontsize=12)
plt.title("Feature Correlation Matrix", fontsize=14, fontweight="bold", pad=20)
plt.show()

# def target variable and features
target = "Sales"
features = ["Quantity", "Discount Impact", "Profit Margin", "Profit Rate", "Month"]

# add categorical variables
features += [col for col in df_encoded.columns if "Sub-Category_" in col or "Region_" in col]

# create features and target
x = df_encoded[features]
y = df_encoded[target]

# split data
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# define models
models = {
    "Linear Regression": LinearRegression(),
    "Random Forest": RandomForestRegressor(n_estimators=100, random_state=42),
    "XGBoost": XGBRegressor(n_estimators=100, random_state=42)
}

# dictionary to store results
results = {}

# train each model
for name, model in models.items():
    model.fit(x_train, y_train)
    y_pred = model.predict(x_test)

# generate predictions
y_pred_lr = models["Linear Regression"].predict(x_test)
y_pred_rf = models["Random Forest"].predict(x_test)
y_pred_xgb = models["XGBoost"].predict(x_test)

# compare predictions
predictions_comparison = pd.DataFrame({
    "Actual Sales": y_test,
    "Predicted LR": y_pred_lr,
    "Predicted RF": y_pred_rf,
    "Predicted XGB": y_pred_xgb
})

print(predictions_comparison.head())

# create plot predictions vs actual sales
def plot_predictions(y_actual, y_pred, model_name):
    plt.figure(figsize=(8, 5))
    plt.scatter(y_actual, y_pred, alpha=0.5, label=model_name)
    plt.plot([y_actual.min(), y_actual.max()], [y_actual.min(), y_actual.max()], "--", color="red")
    plt.xlabel("Actual Sales")
    plt.ylabel("Predicted Sales")
    plt.title(f"Actual vs. Predicted Sales - {model_name}")
    plt.legend()
    plt.show()

# plot predictions
plot_predictions(y_test, y_pred_lr, "Linear Regression")
plot_predictions(y_test, y_pred_rf, "Random Forest")
plot_predictions(y_test, y_pred_xgb, "XGBoost")

# calculate MAE and RMSE
models_errors = {}

for name, y_pred in zip(["Linear Regression", "Random Forest", "XGBoost"], [y_pred_lr, y_pred_rf, y_pred_xgb]):
    mae = mean_absolute_error(y_test, y_pred)
    rmse = mean_squared_error(y_test, y_pred) ** 0.5

    models_errors[name] = {"MAE": mae, "RMSE": rmse}

# convert to dataFrame
models_errors_df = pd.DataFrame(models_errors).T
print(models_errors_df)

# feature importance
feature_importance = models["Random Forest"].feature_importances_
features = x_train.columns

# dataFrame
importance_df = pd.DataFrame({"Feature": features, "Importance": feature_importance})
importance_df = importance_df.sort_values(by="Importance", ascending=False)

# plot feature importance
plt.figure(figsize=(10, 5))
sns.barplot(x=importance_df["Importance"], y=importance_df["Feature"])
plt.title("Feature Importance - Random Forest")
plt.xlabel("Importance")
plt.ylabel("Feature")
plt.show()

# parameter grid
param_grid = {
    "n_estimators": [100, 200, 300],
    "max_depth": [5, 10, 20],
    "min_samples_split": [2, 5, 10]
}

# perform grid search
rf = RandomForestRegressor(random_state=42)
grid_search = GridSearchCV(rf, param_grid, cv=5, scoring="neg_mean_absolute_error", n_jobs=-1)
grid_search.fit(x_train, y_train)

# best parameters
print("Best parameters:", grid_search.best_params_)

# train with best hyperparameters
best_rf = RandomForestRegressor(n_estimators=300, max_depth=20, min_samples_split=2, random_state=42)
best_rf.fit(x_train, y_train)

# predictions
y_pred_best_rf = best_rf.predict(x_test)

# evaluate performance
mae = mean_absolute_error(y_test, y_pred_best_rf)
rmse = mean_squared_error(y_test, y_pred_best_rf) ** 0.5

# results
print("Random Forest (Tuned) - MAE:", mae)
print("Random Forest (Tuned) - RMSE:", rmse)

# create plot predictions vs actual sales (Random Forest Tuned)
def plot_predictions(y_actual, y_pred, model_name="Random Forest"):
    plt.figure(figsize=(8, 5))
    plt.scatter(y_actual, y_pred, alpha=0.5, label=model_name)
    plt.plot([y_actual.min(), y_actual.max()], [y_actual.min(), y_actual.max()], "--", color="red")
    plt.xlabel("Actual Sales")
    plt.ylabel("Predicted Sales")
    plt.title(f"Actual vs. Predicted Sales - {model_name}")
    plt.legend()
    plt.show()

# plot predictions
plot_predictions(y_test, y_pred_rf, "Random Forest Tuned")